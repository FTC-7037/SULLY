#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     MotorMotorServo, sensorI2CMuxController)
#pragma config(Sensor, S2,     Left_IR,        sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     Right_IR,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     SMUX,           sensorI2CCustom)
#pragma config(Motor,  motorB,          R_Spin,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          L_Spin,        tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     LeftMotor,     tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     RightMotor,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     TowerLift,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Lift,          tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C3_1,    Gripper,              tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//define how your robot is wired
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "MyrobotLIB.h"
#include "hitechnicLIB.h"// include file for the hitechnic mux
#include "lego-light.h"
#include "lego-touch.h"
#include "forwardforinches.h"
// include support and driver files above
		int quadrant;
		float left_encoder =nMotorEncoder	[LeftMotor];
		float Right_encoder=nMotorEncoder[RightMotor];

const tMUXSensor light = msensor_S4_1;
int Value_light = LSvalRaw(light);

const tMUXSensor gyroscope		= msensor_S4_2;
int value_Gyro =LSvalNorm(gyroscope);

const tMUXSensor touch				= msensor_S4_3;
bool Touch_pressed =TSreadState(touch);

const tMUXSensor port4				= msensor_S4_4;//open port

//define int,double,const, or the sensors attached to the SMUX controller above.

void initializeRobot();
void Routine1();
void Routine2();
void Routine3();
void Routine4();
void locateInfaRedBeacon();
void TrackLineOnRamp();
void CheckTouch();
// place "void" commands above
/*


*/
//list of user defined commands above

task main()// entrypoint of the program
{


  	//find ir quadrant with left and right IRsensors //
	//run coresponding autonomous routine
	//track line on center of ramp
  waitForStart(); // Wait for the beginning of autonomous phase.
}




//define bodies for "voided" commands or proceedures below;
void initializeRobot()
{
	//initialize
  return;
}
void Routine1()//run only if quadrant one
{
servo[Gripper]=6;
wait1Msec(200);
encoder_forward(50,1200);
left90enc();
encoder_forward(30,500);
//lift block
motor[TowerLift]=50;
wait10Msec(400);
motor[TowerLift]=0;
//
motor[Lift]=50;
wait10Msec(300);
motor[Lift]=0;
//
encoder_forward(50,1600);
wait1Msec(200);
//
servo[Gripper]=100;
wait10Msec(500);
//
encoder_backward(-50,1000);
wait1Msec(200);
//
right90enc();
wait1Msec(200);
//
encoder_forward(90,8000);
wait1Msec(200);
//
right45enc();
wait1Msec(200);
//
}
void Routine2()
{

}
void Routine3()
{

}
void Routine4()
{

}
void locateInfaRedBeacon()
{

}
void TrackLineOnRamp()
{

}
void CheckTouch()
{
    // Check if the sensor is pressed or not.
    if (Touch_pressed==true)
    {
      nxtDisplayCenteredBigTextLine(3, "ACTIVE");
  	}else
  		{
      	nxtDisplayCenteredBigTextLine(3, "INACTIVE");
    		wait1Msec(50);
 		 	}
}
